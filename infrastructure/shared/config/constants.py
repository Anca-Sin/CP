"""
Shared constants and helper functions for AWS CDK infrastructure.
Keeps everything consistent across all business units.
"""

from typing import Dict
import os
from constructs import Construct
from aws_cdk import aws_s3_deployment as s3deploy


def get_mandatory_tags(business_unit: str, country: str = "DE", environment: str = "dev") -> Dict[str, str]:
    """
    Generates tags for all AWS resources in the business group.

    Tags help track costs and filter resources in AWS Console.
    Every S3 bucket, Lambda function, CloudFront distribution gets these tags.
    AWS then tracks costs per tag in Cost Explorer.

    Args:
        business_unit: construction, retail, etc.
        country: Country code for operations ("DE", "RO", etc.)
        environment: dev, prod

    Returns:
        Dictionary of tags to apply for AWS resources
    """
    return {
        # Parent organization name - shows up in AWS billing reports
        "Organization": "RanjdarGroup",

        # Which business this belongs to - most important for cost tracking
        "BusinessUnit": business_unit,

        # Country for multinational operations and tax compliance
        "Country": country,

        # Helps separate current and future dev vs prod costs
        "Environment": environment,

        # For university assignment - remove or change to "Production" after passing the module
        "Project": "Portfolio",

        # Accounting code - each business/country gets unique code (increment if needed in the future)
        "CostCenter": f"{business_unit}-{country.lower()}-001"
    }


def get_resource_names(business_unit: str, resource_type: str, country: str = "") -> str:
    """
    Creates consistent AWS resource names.

    S3 buckets need globally unique names across ALL AWS accounts.
    This pattern prevents conflicts and makes resources easier to find.

    Args:
        business_unit: construction, retail, etc.
        resource_type: S3 bucket, API Gateway, DynamoDB table
        country: DE, RO, etc.

    Returns:
        Formatted resource name in lowercase.

    Examples:
        ranjdargroup-construction-website (S3 Bucket)
        ranjdargroup-construction-de-api (API Gateway)
        ranjdargroup-retail-ro-dynamodb (DynamoDB table)
    """
    parts = ["ranjdargroup", business_unit] # Hardcore org name - lowercase version of Organization tag
    if country:
        parts.append(country.lower())
    parts.append(resource_type)

    # AWS requires lowercase for most resource names
    return "-".join(parts).lower()


def is_prod_environment(environment: str) -> bool:
    """
    Checks if we're in production.

    Critical for RemovalPolicy - prod should NEVER auto-delete.
    Propagates to retention periods, backup schedules, and alerting.

    Args:
        environment: dev, prod

    Returns:
        True if production environment, False otherwise.
    """
    return environment.lower() == "prod"


def get_retention_days(environment: str) -> int:
    """
    Defines how long to keep logs and backups.

    CloudWatch logs cost 0,03/GB
    Dev = 7 days (saves me money), Prod = 90 days (compliance)

    Args:
        environment: dev, prod

    Returns:
        The number of days to retain logs/backups.
    """
    if is_prod_environment(environment):
        return 90
    return 7 # Else dev


def generate_api_config(api_url: str, business_unit: str) -> None:
    """
    Generates JS config file with API endpoints for all language versions.

    Gets called during CDK deployment to inject the actual API Gateway into a JS file that the frontend can load.
    Solves:
    - can't know API URL until after deployment
    - need API URL in frontend code
    - manually updating sounds like insanity

    The generated api-config.js gets uploaded automatically by the S3 bucket deployment in website_construct.py.
    Each language folder gets an api-config.js even if HTML doesn't exist yet -> staying consistent for the future

    Future use: can extend the config object with more endpoints like /api/v1/products, api/v1/recruitment, etc.

    Args:
        api_url: base API Gateway URL from CDK deployment
        business_unit:
    """
    # JavaScript config that frontend loads before making API calls
    # Using template literal syntax but it's actually Python f-string (hence double {{)
    config = f"""// Auto-generated by CDK during deployment - DO NOT EDIT
    // Regenerated every deployment with correct API Gateway URLs
    window.API_CONFIG = {{
        baseUrl: '{api_url}',
        contactEndpoint: '{api_url}api/v1/contact',
        businessUnit: '{business_unit}'
    }};"""

    # Generate for all planned languages
    # Even if only /en/ exists now, /de/ and /ro/ configs ready when needed
    # No manual step needed when adding new language - just add HTML files
    for lang in ['en', 'de', 'ro']:
        path = f"website/{business_unit}/{lang}/api-config.js"

        # Create language folder if doesn't exist (for future expansion)
        # exist_ok=True prevents crash if folder already there
        os.makedirs(os.path.dirname(path), exist_ok=True)

        # Write config - overwrites on each deployment (important for API URL updates)
        with open(path, 'w') as f:
            f.write(config)



def deploy_bucket(scope: Construct, business_unit: str, bucket) -> None:
    """
    Deploys website files and generates API config for any business unit.
    Called after API creation = when I have urls, not CDK tokens.

    Args:
        scope: CDK construct scope (the stack)
        business_unit:
        bucket: S3 bucket from website construct
    """
    # Deploy all website files including generated config
    s3deploy.BucketDeployment(
        scope, f"{business_unit}-website-deployment",
        # Currently adding EN else file doesn't end up at the root where S3 website hosting expects it
        sources=[s3deploy.Source.asset(f"website/{business_unit}/en")],
        destination_bucket=bucket
    )